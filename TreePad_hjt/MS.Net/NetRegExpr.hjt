<Treepad version 3.0>
dt=
<node>
NetRegExpr
0
<end node> 5P9i0s8y19Z
dt=Text
<node>
Регулярные выражения в редакторах
1
Регулярные выражения предоставляют сжатую и гибкую систему обозначений, используемую при поиске и замене образцов текста. Доступные в Visual Studio регулярные выражения расширяют набор выражений, используемых в Visual C++ 6.0, обеспечивая более сложный синтаксис.

Следующие регулярные выражения используются в диалоговом окне «Найти», «Заменить», «Найти в файлах» или «Заменить в файлах» для уточнения или расширения условий поиска.

Примечание.   Перед тем, как задействовать регулярные выражение для задания критериев поиска, следует установить флажок «Использовать» в диалоговом окне «Найти», «Заменить», «Найти в файлах» или «Заменить в файлах».
Для обозначения знаков и цифр в строке поиска можно использовать следующие выражения.

Выражение 
Синтаксис 
Описание 
Любой знак 
. 
Обозначает любой одиночный знак, за исключением перевода строки. 
Максимально – ноль или более  
* 
Обозначает ноль или более вхождений предшествующего выражения. 
Максимально — одно или более 
+ 
Обозначает наличие по крайней мере одного вхождения предшествующего выражения. 
Минимально — ноль или более 
@ 
Обозначает ноль или более вхождений предшествующего выражения; соответствие устанавливается для минимально возможного числа знаков. 
Минимально — одно или более 
# 
Обозначает одно или несколько вхождений предшествующего выражения; соответствие устанавливается для минимально возможного числа знаков. 
Повторить n раз 
^n 
Обозначает n вхождений предшествующего выражения. Например, [0-9]^4 обозначает любую последовательность из четырех цифр. 
Набор знаков 
[] 
Обозначает любой из знаков внутри []. Для задания диапазона знаков следует указать начальный и конечный знаки, разделенные тире, например, [a-z]. 
Отсутствующий в наборе знак 
[^...] 
Обозначает любой знак, отсутствующий в наборе знаков, следующем за ^. 
Начало строки 
^ 
Указывает, что соответствие следует искать в начале строки. 
Конец строки 
$ 
Указывает, что соответствие следует искать в конце строки. 
Начало слова 
< 
Соответствие обнаруживается только, если в данной точке текста начинается слово. 
Конец слова 
> 
Соответствие обнаруживается только, если в данной точке текста заканчивается слово. 
Группировка 
() 
Группирует подвыражение. 
ИЛИ 
| 
Указывает, что для поиска соответствия следует использовать выражение, расположенное либо до, либо после символа ИЛИ (|). Обычно используется в группе. Например, (sponge|mud) bath соответствует "sponge bath" и "mud bath". 
Escape-знак 
\ 
Обозначает знак, следующий за обратной косой чертой (\). Позволяет искать знаки системы обозначений, используемой для задания регулярных выражений, такие как { и ^. Например, с помощью \^ производится поиск знака ^. 
Помеченное выражение 
{} 
Помечает текст, обозначаемый выражением в фигурных скобках. 
n-й помеченный текст 
\n 
Применяется в выражениях, используемых для поиска или замены, указывая текст, обозначаемый n-м помеченным выражением, где n является числом от 1 до 9. 


В выражениях, используемых для замены, совпавший текст полностью вставляется с помощью \0.
Выровненное по правому краю поле 
\(w,n) 
В выражениях, используемых для замены, выравнивает по правому краю n-е помеченное выражение в поле длиной, по крайней мере, w знаков. 
Выровненное по левому краю поле 
\(-w,n) 
В выражениях, используемых для замены, выравнивает по левому краю n-е помеченное выражение в поле длиной, по крайней мере, w знаков. 
Предотвращение нахождения соответствия 
~(X) 
Препятствует нахождению соответствия, если X появляется в выражении на данной позиции. Например, real~(ity) обозначает real в словах realty и really, но не в слове reality. 
Буквенно-цифровой знак 
:a 
Соответствует выражению ([a-zA-Z0-9]). 
Знак алфавита 
:c 
Соответствует выражению ([a-zA-Z]). 
Десятичная цифра 
:d 
Соответствует выражению ([0-9]). 
Шестнадцатеричная цифра 
:h 
Соответствует выражению ([0-9a-fA-F]+). 
Идентификатор 
:i 
Соответствует выражению ([a-zA-Z_$][a-zA-Z0-9_$]*). 
Рациональное число 
:n 
Соответствует выражению (([0-9]+.[0-9]*)|.([0-9]*.[0-9]+)|([0-9]+)). 
Строка, заключенная в кавычки 
:q 
Соответствует выражению (("[^"]*")|.('[^']*')) 
Строка алфавитных знаков 
:w 
Соответствует выражению ([a-zA-Z]+). 
Десятичное целое число 
:z 
Соответствует выражению ([0-9]+). 
Escape-знак 
\e 
Знак Юникода U+001B. 
Знак Bell 
\g 
Знак Юникода U+0007. 
Знак BACKSPACE 
\h 
Знак Юникода U+0008. 
Перенос строки 
\n 
Обозначает независимый от используемой платформы знак переноса строки. В выражениях, используемых для замены, с помощью данного выражения вставляется перевод строки. 
Знак TAB 
\t 
Обозначает знак табуляции (знак Юникода U+0009). 
Знак Юникода 
\x#### или \u#### 
Обозначает знак, задаваемый значением в кодировке Юникод, где #### представляет собой шестнадцатеричное число. Имеется возможность указать знак, не входящий в Basic Multilingual Plane (то есть, знак-заместитель), с помощью кодовых позиций кодировки ISO 10646 или двух кодовых позиций кодировки Юникод с передачей значения пары символов-заместителей. 

В следующей таблице приведены элементы синтаксиса, используемые для поиска соответствия с помощью стандартных свойств знаков Юникода. Двухбуквенные аббревиатуры здесь совпадают с аббревиатурами, приведенными в базе данных свойств знаков Юникода. Эти аббревиатуры могут быть указаны в качестве составляющих набора символов. Например, выражение [:Nd:Nl:No] обозначает любую цифру.

Выражение 
Синтаксис 
Описание 
Буква в верхнем регистре 
:Lu 
Обозначает любую (одну) прописную букву. Например, :Luhe соответствует "The", но не "the". 
Буква в нижнем регистре 
:Ll 
Обозначает любую (одну) строчную букву. Например, :Llhe соответствует "the", но не "The". 
Буква в титульном регистре 
:Lt 
Обозначает сочетание знаков, состоящее как из букв в верхнем, так и в нижнем регистре, например Nj и Dz. 
Знак-модификатор 
:Lm 
Обозначает буквы или знаки пунктуации, такие как запятые, ударения или двойные штрихи, используемые для видоизменения предшествующей буквы. 
Прочая буква 
:Lo 
Обозначает прочие буквы, такие как готическая буква "ahsa". 
Десятичная цифра 
:Nd 
Обозначает десятичные цифры (0-9) и их двухбайтовые эквиваленты. 
Буквенная цифра 
:Nl 
Обозначает буквенные цифры, такие как римские цифры или идеографическое число ноль. 
Прочая цифра 
:No 
Обозначает прочие цифры, такие как старое итальянское число один. 
Открывающий знак пунктуации 
:Ps 
Обозначает открывающие знаки пунктуации, такие как скобки (в т.ч. фигурные). 
Закрывающий знак пунктуации 
:Pe 
Обозначает закрывающие знаки пунктуации, такие как скобки (в т. ч. фигурные). 
Начальные кавычки 
:Pi 
Обозначает начальные двойные кавычки. 
Конечные кавычки 
:Pf 
Обозначает одинарные кавычки и конечные двойные кавычки.  
Тире 
:Pd 
Обозначает тире. 
Соединительные знаки пунктуации 
:Pc 
Обозначает знак подчеркивания или подчеркивание. 
Прочие знаки пунктуации 
:Po 
Обозначает запятые (,), ?, ", !, @, #, %, &, *, \, двоеточия (:), точки с запятой (;), ' и /. 
Разделительный пробел  
:Zs 
Обозначает пробелы. 
Разделитель строк :
Zl 
Обозначает знак Юникода U+2028. 
Разделитель абзацев 
:Zp 
Обозначает знак Юникода U+2029. 
Несамостоятельный знак 
:Mn 
Обозначает несамостоятельные знаки. 
Объединяющий знак 
:Mc 
Обозначает объединяющие знаки. 
Вмещающий знак 
:Me 
Обозначает вмещающие знаки.  
Математический символ 
:Sm 
Обозначает +, =, ~, |, < и > 
Символ денежной единицы 
:Sc 
Обозначает $ и символы других денежных единиц. 
Символ- модификатор 
:Sk 
Обозначает символы-модификаторы, такие как диакритические знаки циркумфлекс, гравис или знак долготы над гласным. 
Прочий символ 
:So 
Обозначает прочие символы, такие как знак авторского права, абзаца и возведения в степень. 
Прочий управляющий символ 
:Cc 
Обозначает конец строки 
Прочий формат 
:Cf 
Форматирующие управляющие знаки, такие как двунаправленные управляющие знаки. 
Символ-заместитель 
:Cs 
Обозначает один символ из пары символов-заместителей. 
Прочие знаки для личного использования 
:Co 
Обозначает любой знак из области знаков для личного использования. 
Прочие не назначенные знаки 
:Cn 
Обозначает знаки, не соответствующие ни одному из знаков Юникода. 

Кроме стандартных свойств знаков Юникода могут указываться следующие дополнительные свойства. Эти свойства могут быть указаны в качестве составляющих набора символов.

Выражение 
Синтаксис 
Описание 
Буквенное 
:Al 
Обозначает любой (один) из указанных знаков. Например, выражение :Alhe соответствует словам "The", "then" и "reached". 
Числовое 
:Nu 
Обозначает любое (одно) из указанных чисел или цифр. 
Знак пунктуации 
:Pu 
Обозначает любой знак пунктуации, такой как ?, @, ' и т. д. 
Пробел 
:Wh 
Обозначает все виды пробелов (пустого пространства), включая издательские и идеографические пробелы. 
Двунаправленные 
:Bi 
Обозначает знаки, используемые в способах письма, где применяется направление "справа налево"; характерных, например, для арабской или еврейской письменности. 
Хангыль 
:Ha 
Обозначает знаки корейского алфавита Хангыль и объединенного Джамо. 
Хирагана 
:Hi 
Обозначает знаки хираганы. 
Катакана 
:Ka 
Обозначает знаки катаканы. 
Идеографические /Хан/Кандзи 
:Id 
Обозначает идеографические знаки (Хан и Кандзи). 

<end node> 5P9i0s8y19Z
dt=Text
<node>
Категория знаков Unicode
2
<end node> 5P9i0s8y19Z
dt=Text
<node>
Symbols
1
В регулярных выражениях используються собственные подстановочные знаки. Все знаки услово можно разделить на знаки, присутствующие только в образце, и знаки, используемые как в образце, так и в заменяющей строке. Паоследние называются escape-последовательностями. Список всех специальных символов регулярных выражение приведён ниже.

<end node> 5P9i0s8y19Z
dt=Text
<node>
Escape-последовательности
2
Большинство основных операторов языка регулярных выражений — это одиночные знаки без escape-знака. Escape-знак «\» (одиночная обратная косая черта, обратный слэш) указывает сканенру регулярных выражений, что следующий за ним знак не является оператором. Например, звездочка (*) интерпретируется парсером как квантор повторения, а звездочка, перед которой стоит обратная косая черта (\*), — смобственно знак звёздочка.

Escape-последовательности, перечисленные в следующей таблице, распознаются как в регулярных выражениях, так и в группах знаков для замены.

Escape-последовательности
Описание 
Обычные знаки
Все знаки, кроме $ ^ { [ ( | ) * + ? \ соответствуют сами себе. 
\a
Соответствует знаку колокольчика (будильника) \u0007. 
\b
Соответствует знаку возврата \u0008, если встречается в классе знаков []; в противном случае см. примечание после этой таблицы. 
\t
Соответствует знаку табуляции \u0009. 
\r 
Соответствует знаку возврата каретки \u000D. 
\v 
Соответствует знаку вертикальной табуляции \u000B. 
\f 
Соответстсвует знаку подачи бланка \u000C. 
\n 
Соответствует знаку новой строки \u000A. 
\e 
Соответствует escape-знаку \u001B. 
\040 
Соответствует знаку ASCII как восьмеричному числу (до трех разрядов); числа, начинающиеся не с нуля представляют собой обратные ссылки, если они состоят из одной цифры или соответствуют номеру собираемой группы. (Дополнительные сведения см. в разделе Обратные ссылки.) Например, знак \040 соответствует пробелу. 
\x20 
Соответствует знаку ASCII в шестнадцатеричном представлении (строго две цифры). 
\cC 
Соответствует управляющему знаку ASCII; например, \cC — CTRL+C. 
\u0020 
Соответствует знаку Юникода в шестнадцатеричном представлении (строго четыре цифры). 
\ 
Со следующим знаком, который не распознается как escape-знак, соответствует этому знаку. Например, \* — то же самое, что \x2A. 

Примечание.   Escape-последовательность \b — исключение. В регулярном выражении \b означает границу слова (между знаками \w и \W), за исключением класса знаков [], в котором \b соответствует знаку возврата. В группе знаков для замены \b всегда означает пробел.

<end node> 5P9i0s8y19Z
dt=Text
<node>
Подстановки
2
Подстановки допускаются только в группах знаков для замены. В регулярных выражениях вместо них используются обратные ссылки (например, \1). Подробнее об обратных ссылках см. в разделах Обратные ссылки и Конструкции обратных ссылок.

В группах знаков для замены распознаются только две специальные конструкции: escape-знаки и подстановки. Все синтаксические конструкции, описанные ниже, допускаются только в регулярных выражениях. Они не распознаются в группах знаков для замены. Например, группа знаков для замены a*${txt}b вставляет строку "a*", за которой следует подстрока, соответствующая собираемой группе txt, если она имеется, а затем строка "b". Знак звездочки (*) не распознается как метазнак внутри группы знаков для замены. Группы знаков $ также не распознаются в группах знаков для замены регулярных выражений. В регулярных выражениях знак $ обозначает конец строки.

В следующей таблице приводится описание именованных и нумерованных групп знаков для замены.

Знак 
Описание 
$номер 
Замещает последнюю подстроку, соответствующую группе с десятичным номером номер. 
${имя} 
Замещает последнюю подстроку, соответствующую группе (?<имя> ). 
$$ 
Substitutes a single "$" literal. 
$& 
Замещает копию самого соответствия целиком. 
$` 
Замещает весь текст строки входных данных до соответствия. 
$' 
Замещает весь текст строки входных данных после соответствия. 
$+ 
Замещает последнюю собранную группу. 
$_ 
Замещает всю строку входных данных. 

См. также

<end node> 5P9i0s8y19Z
dt=Text
<node>
Классы знаков
2
Класс знаков — это набор знаков, который будет соответствовать любому знаку, входящему в этот набор. В следующей таблице приведен синтаксис соответствия знаков.

Класс знаков Описание 
. Соответствует любому знаку, кроме \n. Если задан параметр Singleline, точка соответствует любому знаку. Дополнительные сведения см. в разделе Параметры регулярных выражений. 
[aeiou] Соответствует любому из знаков, перечисленных в заданном наборе. 
[^aeiou] Соответствует любому из знаков, не перечисленных в заданном наборе. 
[0-9a-fA-F] С помощью дефиса (–) задается диапазон последовательно расположенных знаков. 
\p{имя} Соответствует любому знаку в классе знаков, заданном параметром {имя}. Поддерживаемые имена — группы и диапазоны блоков Юникода. Например: Ll, Nd, Z, IsGreek, IsBoxDrawing. 
\P{имя} Соответствует тексту, не включенному в группы и диапазоны блоков, заданные параметром {имя}. 
\w Соответствует любому алфавитно-цифровому знаку. Эквивалентен категориям знаков Юникода 
[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}]. Если с помощью параметра ECMAScript задано поведение, совместимое с ECMAScript, класс \w равнозначен [a-zA-Z_0-9]. 
\W Соответствует любому знаку, не являющемуся цифрой или буквой. Эквивалентен категориям Юникода 
[^\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}]. Если с помощью параметра ECMAScript задано поведение, совместимое с ECMAScript, класс \W равнозначен [^a-zA-Z_0-9]. 
\s Соответствует любому знаку пробела. Эквивалентен категориям знаков Юникода 
[\f\n\r\t\v\x85\p{Z}]. Если с помощью параметра ECMAScript задано поведение, совместимое с ECMAScript, класс \s равнозначен [ \f\n\r\t\v]. 
\S Соответствует любому знаку, не являющемуся пробелом. Эквивалентен категориям знаков Юникода 
[^\f\n\r\t\v\x85\p{Z}]. Если с помощью параметра ECMAScript задано поведение, совместимое с ECMAScript, класс \S равнозначен [^ \f\n\r\t\v]. 
\d Соответствует любой десятичной цифре. Поведение аналогично параметру ECMAScript \p{Nd} для знаков Юникода и [0-9] для других знаков. 
\D Соответствует любому знаку, кроме цифр. Поведение аналогично параметру ECMAScript \P{Nd} для знаков Юникода и [^0-9] для других знаков. 

Категорию Юникода, к которой принадлежит знак, можно найти с помощью метода GetUnicodeCategory.

Дополнительные сведения о категориях знаков Юникода см. в документе Unicode Data File Format, доступном на веб-узле Технической комиссии Юникода (UTC): http://www.unicode.org/Public/UNIDATA/UnicodeData.html.

<end node> 5P9i0s8y19Z
dt=Text
<node>
RegExpr
1
В отличие от языка Perl, регулярные выражения в .Net не являются символьными данными, и обрабатываются отдельными классами. Такими классами в .Net служат классы Capture, CaptureCollection, Group, GroupCollection, Match, MatchCollection, RegEx, RegExCompilationInfo. Также в регулярных выражениях используются делегат MatchEvaluator (ссылка на функции, обрабатывающих результаты регулярных выражений) и перечисление RegexOptions, задающая опции применения регулярного выражения.

Грубо говоря, Match соответствует значениям переменных, возвращаемых операторами  s/// и m// в Perl, RegexOptions соответствуют опциям, которые располагаются после закрывающегося слеша данного оператора, Group соответствует значению найденного сопоставления, обозначаемого символами $1, $2 и т.д., Capture возвращает подстроку, захваченную (соответствующую) сопоставлению при поиске, не попадающая в группы. Collections представляют коллекции из этих элементов, если в процессе сопоставления получено несколько значений (захватов).

Регулярные выражения определены в пространстве имён System.Text.RegularExpressions Поэтому для использования регулярных выражений перед их использованием необходимо указать директивы:

В Visual Basic

Imports System
Imports System.Text
Imports System.Text.RegularExpressions
Imports System.Collections

В Visual C#

using System
using System.Text
using System.Text.RegularExpressions
using System.Collections

В Visual C++

#using <mscorlib.dll>
#using <System.dll>
#using <System.Text.dll>

using namespace System;
using namespace System::Text;
using namespace System::Collections;
using namespace System::Text::RegularExpressions;

Далее перейдём к описанию классов этого пространства имён.

<end node> 5P9i0s8y19Z
dt=Text
<node>
Class Capture
1
Класс Capture

Выдаёт результаты отдельного поиска (захвата) подвыражения. Capture предоставляет одну подстроку для отдельного успешного поиска.

Данный объект не имеет открытого конструктора. Возврат результатов поиска осуществляется через коллекцию элементов Captures.

Определение типа переменной Captures:

[VB]

Dim capt As Capture

[VC#]

Capture capt;

[VC++]

Regex *r = new Regex( pat, RegexOptions::IgnoreCase )
Capture *capt = r -> Captures[0];
 /* Клесс Capture не имеет открытого конструктора, значит оператор new использовать нельзя */

Открытые свойства класса:

* Index;
* Length;
* Value;

Открытые методы класса:

* Equals;
* GetHashCode;
* GetType;
* ToString;

<end node> 5P9i0s8y19Z
dt=Text
<node>
Index
2
Index -- Позиция в исходной строке, где был обнаружен первый знак захваченной подстроки;

Значение свойства:
	Начальная позиция в исходной строке, где была обнаружена захваченная подстрока (отсчёт ведётся от нуля).

Примеры:

[VB]

Public ReadOnly Property Index As Integer

Dim iPos As Integer
iPos = capt.Index

[VC#]

public int Index {get;}

int iPos = capt.Index;

[VC++]

public: __property int get_Index();

int iPos = capt -> get_Index();

[JScript]
public function get Index() : int;

<end node> 5P9i0s8y19Z
dt=Text
<node>
Length
2
Length -- Длина захваченной подстроки;

Примеры:

[VB]

Public ReadOnly Property Length As Integer

Dim iLen As Integer
iLen = capt.Length

[VC#]

public int Length {get;}

int iLen = capt.Length;

[VC++]

public: __property int get_Length();

int iLen = capt -> get_Length();

[JScript]
public function get Length() : int;

<end node> 5P9i0s8y19Z
dt=Text
<node>
Value
2
Value -- Получает найденную подстроку из входной строки;

Значение свойства:
    Фактическая подстрока, захваченная регулярным выражением;
    
Примеры:

[VB]

Public ReadOnly Property Value As String

Dim substring As String
substring = capt.Value;

[VC#]

public string Value {get;}

string substring;
substring = capt.Value;

[VC++]

public: __property String* get_Value();

String *substring = new String("");
substring = capt -> get_Value;

[JScript]
public function get Value() : String;

<end node> 5P9i0s8y19Z
dt=Text
<node>
Equals
2
Equals (перегружен) -- Определяет, равны ли два объекта типа Capture;

Параметры:
    obj -- Объект, который нужно сравнить с текущим объектом;
Возвращаемое значение:
    true, если указанный объект равен текущему объекту, и false в противном случае;
Примечания
    Стандартная реализация Equals поддерживает только равенство ссылок, но в производных классах можно переопределить этот метод так, чтобы он поддерживал равенство значений.

    Для ссылочных типов равенство определяется как совпадение объектов, т.е. ссылки считаются равными, если они указывают на один и тот же объект. Для типов значений равенство определяется как поразрядное равенство. Класс ValueType поддерживает типы значений.

Примечания для реализующих объектов:  

    Этот метод может быть переопределен в производном классе. Например, многие основные типы данных возвращают значение true, если оба объекта представляют одинаковое значение; в противном случае — значение false.

    Этот метод предназначен только для сравнения значений простых типов и объектов. Для сравнения более сложных структур, таких как массивы объектов, этот метод необходимо переопределить.

    Следующие положения должны быть верны для всех реализаций метода Equals. В списке буквы x, y, и z обозначают объекты, не равные пустая ссылка (Nothing в Visual Basic). 

    x.Equals(x) возвращает true, кроме случая, когда х относится к типу с плавающей запятой. См. стандарт IEC 60559:1989, Binary Floating-point Arithmetic for Microprocessor Systems. 
    x.Equals(y) возвращает то же значение, что и y.Equals(x). 
    x.Equals(y) возвращает true, если x и y явлются NaN. 
    (x.Equals(y) && y.Equals(z)) возвращает true, в том и только в том случае, если x.Equals(z) возвращает true. 
    Последующие обращения к x.Equals(y) возвращают то же значение до тех пор, пока объекты, ссылками на которые являются x и y, остаются теми же самыми. 
    x.Equals(пустой ссылке (Nothing)) возвращает false. 
    Дополнительные сведения о необходимых дополнительных настройках, относящихся к методу Equals, см. в разделе, посвященном методу GetHashCode.

    Реализация объекта Equals не должна создавать исключения.

    Для некоторых видов объектов желательно проверять Equals на равенство значений, а не ссылок. Подобные реализации Equals возвращают true, если два объекта имеют одинаковое «значение», даже если они не являются одним и тем же экземпляром. Что именно считается «значением» объекта, зависит от реализатора типа, но обычно это все данные, хранящиеся в переменных экземпляра объекта, или некоторые из них. Например, значение String основано на знаках, содержащихся в строке; метод Equals класса String возвращает true для любых двух экземпляров строк, которые содержат одни и те же знаки в одинаковом порядке.

    Типы, реализующие IComparable, должны переопределять Equals.

    Типы, переопределяющие Equals должны также переопределять GetHashCode; в противном случае Hashtable может работать неправильно.

    Если используемый язык программирования поддерживает перегрузку операторов и применяется перегрузка оператора равенства для данного типа, то этот тип должен переопределять метод Equals. Такие реализации метода Equals должны возвращать те же результаты, что и оператор равенства. Следование этим рекомендациям позволит гарантировать, что код библиотеки классов, использующий Equals (например, ArrayList и Hashtable) функционирует так же, как и оператор равенства, используемый кодом приложения.

Указания по реализации типов значений: 

    Переопределение Equals целесообразно для повышения производительности по сравнению со стандартной реализацией Equals для ValueType. 
    Если переопределить Equals, и язык программирования поддерживает перегрузку операторов, то необходимо перегрузить оператор равенства для нового типа значений. 
Указания по реализации ссылочных типов: 

    Переопределение Equals для ссылочного типа целесообразно, если семантика типа основана на том факте, что тип представляет некоторое значение (или значения). 
    В большинстве ссылочных типов не допускается перегружать оператор равенства, даже в них переопределяется Equals. Однако, если реализуется ссылочный тип, который будет применяться для семантического представления значений, например тип комплексных чисел, необходимо переопределить оператор равенства. 


[VB]

Overloads Public Overridable Function Equals( _
   ByVal obj As Object _
) As Boolean

[VC#]

public: virtual bool Equals(
   Object* obj
);

[VC++]

public: virtual bool Equals(
   Object* obj
);

[JScript]
public function Equals(
   obj : Object
) : Boolean;

<end node> 5P9i0s8y19Z
dt=Text
<node>
GetHashCode
2
GetHashCode (перегружен) -- Служит хеш-функцией для данного типа. Используется, например, в хеш-таблицах;

Возвращаемое значение
    Хеш-код для текущего Object.

Примечания
    Этот метод может быть переопределен в производном классе. Классы значений должны переопределять этот метод для получения хеш-функции, адекватной для класса и гарантирующей лучшее распределение в хеш-таблице. Классы, которые могут быть использованы в качестве ключей хеш-таблицы, также должны переопределять этот метод, так как объекты, используемые в качестве ключей хеш-таблицы, должны создавать свой собственный хеш-код с помощью этого метода. Однако если объекты, используемые в качестве ключей, не обеспечивают полезную реализацию GetHashCode, разработчик может предоставить другой генератор хеш-кода, основанный на интерфейсе System.Collections.IHashCodeProvider, когда создается Hashtable.

    Стандартная реализация GetHashCode не гарантирует ни уникальности, ни целостности, следовательно, она не может применяться в качестве уникального идентификатора объекта для хеширования. В производных классах GetHashCode должен быть переопределен реализацией, возвращающей уникальный хеш-код. Для получения наилучшего результата хеш-код должен основываться на значении поля или свойства экземпляра, а не статического поля или свойства.

Примечания для реализующих объектов:  

    Хеш-функция используется для быстрого создания числа (хеш-кода), соответствующего значению объекта. Хеш-функции обычно специфичны для каждого Type и должны использовать в качестве входного аргумента хотя бы одно из полей экземпляра.

Хеш-функции должны обладать следующими свойствами: 

    Если два объекта одного и того же типа представляют одно и то же значение, то хеш-функция должна возвращать одно и тоже постоянное значение для каждого объекта. 
    Для оптимальной производительности значения хеш-функции должны подчиняться случайному распределению для всех входных аргументов. 
    Хеш-функция должна возвращать точно такое же значение, независимо от того, какие изменения были сделаны в объекте. 
    Например, реализация GetHashCode, обеспеченная с помощью класса String, возвращает уникальные хеш-коды для уникальных строковых значений. Следовательно, два объекта String возвращают тот же хеш-код, если они представляют одно и то же строковое значение. Кроме того, этот метод использует все знаки в строке для создания случайно распределенного результата, даже если входной параметр ограничен каким-либо диапазоном (например, многие пользователи применяют строки, содержащие только первые 128 знаков набора ASCII, хотя строка может содержать любые из 65535 знаков Юникода).

    GetHashCode должен всегда возвращать одно и тоже значение для конкретного экземпляра объекта. Для производных классов Object GetHashCode можно делегировать реализации Object.GetHashCode в том и только в том случае, если эти производные классы определяют равенство значений как равенство ссылок и тип не является типом значений.

    Предоставление хорошей хеш-функции для каждого класса может значительно ускорить добавление соответствующих объектов в хеш-таблицу. Поиск элементов в хеш-таблице при хорошей реализации хеш-функции занимает постоянное время (например, O(1)). Скорость поиска элементов при плохой реализации хеш-функции зависит от числа элементов в хеш-таблице (например, O(n), где n — число элементов в хеш-таблице). Вычисление хеш-функций не должно отнимать значительный объем ресурсов.

    Реализации GetHashCode не должны приводить к зацикливанию ссылок. Например, если ClassA.GetHashCode вызывает ClassB.GetHashCode, то ClassB.GetHashCode не должен вызывать ClassA.GetHashCode ни явным, ни неявным способом.

    Реализации GetHashCode не должны создавать исключения.

    Производные классы, переопределяющие GetHashCode, должны также переопределять Equals для обеспечения того, чтобы два, считающиеся равными, объекта имели один и тот же хеш-код; в противном случае Hashtable может работать неправильно.

Примеры реализаций:

[VB]
Public Overridable Function GetHashCode() As Integer

[VC#]
public virtual int GetHashCode();

[VC++]
public: virtual int GetHashCode();

[JScript]
public function GetHashCode() : int;

<end node> 5P9i0s8y19Z
dt=Text
<node>
GetType
2
GetType (перегружен) -- Возвращает тип заданной переменной класса (Capture);

Возвращаемое значение:
    Экземпляр Type, представляющий точный тип среды выполнения для данного экземпляра;

Примечания:
    Для двух объектов x и y, имеющих идентичные типы среды выполнения, Object.ReferenceEquals(x.GetType(),y.GetType()) возвращает true.

    Объект Type представляет метаданные, связанные с классом текущего Object.

Пример реализации:

[VB]
Public Function GetType() As Type

[VC#]
public Type GetType();

[VC++]
public: Type* GetType();

[JScript]
public function GetType() : Type;

<end node> 5P9i0s8y19Z
dt=Text
<node>
ToString
2
ToString (переопределён) -- Получает захваченную строку из входной строки. Эту функцию необходимо использовать для получения результатов поиска/замены;

Возвращаемое значение:
    Фактическая подстрока, захваченная сопоставлением;

Примечания:
    ToString фактически является внутренним обращением к Value;
Примеры реализации:

[VB]
Overrides Public Function ToString() As String

[VC#]
public override string ToString();

[VC++]
public: String* ToString();

[JScript]
public override function ToString() : String;

<end node> 5P9i0s8y19Z
dt=Text
<node>
Class Group
1
Класс Group содержит в себе результаты обособленной строки (группы) захвата при поиске.. Группа захвата может возвратить нуль, одну или более строк в отдельном  поисковом сопоставлении  с образцом из-за модификаторов, поэтому Group предоставляет коллекцию объектов Capture.

Класс являетося наследником класса Capture;

Примечания
Group наследует от Capture, поэтому доступ к последней захваченной подстроке осуществляется непосредственно. (Иными словами, экземпляр Group эквивалентен последнему элементу коллекции, возвращенной свойством Captures.)

Требования
Пространство имен: System.Text.RegularExpressions

Члены класса:

Открытые свойства

Captures 

Получает коллекцию всех захватов, сопоставляемых группой захвата, в порядке самый дальний-крайний слева-первый (или в порядке самый дальний-крайний справа-первый, если регулярное выражение изменено с помощью параметра RegexOptions.RightToLeft). Коллекция может иметь нуль или более элементов. 

Index (унаследовано от Capture) 

Позиция в исходной строке, где был обнаружен первый знак захваченной подстроки. 

Length (унаследовано от Capture) 

Длина захваченной подстроки. 

Success 

Получает значение, показывающее, успешно ли сопоставление. 
открытое свойствоValue (унаследовано от Capture) 

Получает захваченную подстроку из входной строки. 

Открытые методы

Equals (унаследовано от Object) 

Перегружен. Определяет, равны ли два экземпляра Object. 

GetHashCode (унаследовано от Object) 

Служит хеш-функцией для конкретного типа, пригоден для использования в алгоритмах хеширования и структурах данных, например в хеш-таблице. 

GetType (унаследовано от Object) 

Возвращает Type текущего экземпляра. 

static (Shared в Visual Basic) Synchronized 

Возвращает объект Group, эквивалентный поставляемому, который можно использовать в нескольких потоках. 

ToString (унаследовано от Capture) 

Переопределен. Получает захваченную подстроку из входной строки. 

<end node> 5P9i0s8y19Z
dt=Text
<node>
Captures
2
Captures -- Получает коллекцию всех захватов, сопоставляемых группой захвата, в порядке самый дальний-крайний слева-первый (или в порядке самый дальний-крайний справа-первый, если регулярное выражение изменено с помощью параметра RegexOptions.RightToLeft). Коллекция может иметь нуль или более элементов.

Значение свойства
Коллекция подстрок, сопоставляемых группой.

Примеры описания:
[VB]
Public ReadOnly Property Captures As CaptureCollection

[VC#]
public CaptureCollection Captures {get;}

[VC++]
public: __property CaptureCollection* get_Captures();

[JScript]
public function get Captures() : CaptureCollection;

Значение свойства

<end node> 5P9i0s8y19Z
dt=Text
<node>
Success
2
Success -- Получает значение, показывающее, успешно ли сопоставление.

Значение свойства
	true, если сопоставление успешно; в противном случае — false.

Примечания
	Свойство Success является «true», если данной группой была захвачена хотя бы одна строка. Это эквивалентно логическому выражению (Group.Captures.Count > 0).

Примеры описания:

[VB]
Public ReadOnly Property Success As Boolean

[VC#]
public bool Success {get;}

[VC++]
public: __property bool get_Success();

[JScript]
public function get Success() : Boolean;

<end node> 5P9i0s8y19Z
dt=Text
<node>
Synchronized
2
Synchronized -- Возвращает объект Group, эквивалентный поставляемому, который можно использовать в нескольких потоках.

Параметры
	inner -- Входной объект Group. 

Возвращаемое значение
	Объект Group регулярного выражения.

Примеры описания:

[VB]
Public Shared Function Synchronized( _
   ByVal inner As Group _
) As Group

[VC#]
public static Group Synchronized(
   Group inner
);

[VC++]
public: static Group* Synchronized(
   Group* inner
);

[JScript]
public static function Synchronized(
   inner : Group
) : Group;

<end node> 5P9i0s8y19Z
dt=Text
<node>
Class March
1
Класс Match

Данный класс предоставляет результаты отдельного сопоставления с образцом регулярного выражения.

Класс является наследником класса Group

Примечания
	Поскольку отдельное сопоставление может включать в себя несколько групп захвата, Match имеет свойство Groups, возвращающее GroupCollection. GroupCollection имеет в себе члены, возвращающие каждую группу. Match наследует из Group, поэтому доступ ко всей сопоставляемой подстроке может осуществляться непосредственно. Иными словами, экземпляр Match эквивалентен Match.Groups[0] (Match.Groups(0) в Visual Basic) . Объект Match является постоянным и не имеет открытого конструктора.

Требования
	Пространство имен: System.Text.RegularExpressions

Открытые свойства

Captures (унаследовано от Group) 

Получает коллекцию всех захватов, сопоставляемых группой захвата, в порядке самый дальний-крайний слева-первый (или в порядке самый дальний-крайний справа-первый, если регулярное выражение изменено с помощью параметра RegexOptions.RightToLeft). Коллекция может иметь нуль или более элементов. 

static (Shared в Visual Basic)Empty 

Получает пустую группу. Все неудавшиеся сопоставления возвращают данное пустое сопоставление. 

Groups 

Получает коллекцию групп, сопоставляемую по регулярному выражению. 

Index (унаследовано от Capture) 

Позиция в исходной строке, где был обнаружен первый знак захваченной подстроки. 

Length (унаследовано от Capture) 

Длина захваченной подстроки. 

Success (унаследовано от Group) 

Получает значение, показывающее, успешно ли сопоставление. 

Value (унаследовано от Capture) 

Получает захваченную подстроку из входной строки. 

Открытые методы

Equals (унаследовано от Object) 

Перегружен. Определяет, равны ли два экземпляра Object. 

GetHashCode (унаследовано от Object) 

Служит хеш-функцией для конкретного типа, пригоден для использования в алгоритмах хеширования и структурах данных, например в хеш-таблице. 

GetType (унаследовано от Object) 

Возвращает Type текущего экземпляра. 

NextMatch 

Возвращает новое Match с результатами для следующего сопоставления, начинающегося с позиции, где закончилось последнее сопоставление (с символа за последним сопоставляемым символом). 

Result 

Возвращает распространение переданного замещаемого образца. Например, если замещаемый образец представляет собой $1$2, Result возвращает конкатенацию Groups[1].Value and Groups[2].Value (Groups(1).Value and Groups(2).Value в Visual Basic). 

static (Shared в Visual Basic)Synchronized 

Возвращает экземпляр Match, эквивалентный поставляемому, который можно использовать в нескольких потоках. 

ToString (унаследовано от Capture) 

Переопределен. Получает захваченную подстроку из входной строки. 

<end node> 5P9i0s8y19Z
dt=Text
<node>
Empty
2
Empty -- Получает пустую группу. Все неудавшиеся сопоставления возвращают данное пустое сопоставление.

Значение свойства:
	Пустой Match.

Примечания:
	Не следует использовать данное свойство, чтобы определить, успешно ли сопоставление. Вместо этого воспользуйтесь Success.

Примеры определения:

[VB]
Public Shared ReadOnly Property Empty As Match

[VC#]
public static Match Empty {get;}

[VC++]
public: __property static Match* get_Empty();

[JScript]
public static function get Empty() : Match;

<end node> 5P9i0s8y19Z
dt=Text
<node>
Groups
2
Groups -- Получает коллекцию групп, сопоставляемую по регулярному выражению.

Значение свойства
	Группы символов, подбираемые по образцу.

Примеры описания:

[VB]
Public Overridable ReadOnly Property Groups As GroupCollection

[VC#]
public virtual GroupCollection Groups {get;}

[VC++]
public: __property virtual GroupCollection* get_Groups();

[JScript]
public function get Groups() : GroupCollection;

<end node> 5P9i0s8y19Z
dt=Text
<node>
NextMatch
2
NextMatch -- Возвращает новое Match с результатами для следующего сопоставления, начинающегося с позиции, где закончилось последнее сопоставление (с символа за последним сопоставляемым символом).

Возвращаемое значение
	Следующий объект Match регулярного выражения.

Примечания
	Данная функция подобна вызову Match и передаче (Index+Length) как новой стартовой позиции, но от непосредственного вызова Match она отличается тем, что, обрабатывая случаи сопоставления с нулевой длиной, гарантирует прогресс к концу строки.

Примеры описания:

[VB]
Public Function NextMatch() As Match

[VC#]
public Match NextMatch();

[VC++]
public: Match* NextMatch();

[JScript]
public function NextMatch() : Match;

<end node> 5P9i0s8y19Z
dt=Text
<node>
Result
2
Result -- Возвращает распространение (результат) переданного замещаемого образца. Например, если замещаемый образец представляет собой $1$2, Result возвращает конкатенацию Groups[1].Value and Groups[2].Value (Groups(1).Value and Groups(2).Value в Visual Basic).

Параметры:
	replacement  -- Используемый функцией замещаемый образец. 
Возвращаемое значение
	Расширенная версия replacement.

Примеры описания:

[VB]
Public Overridable Function Result( _
   ByVal replacement As String _
) As String

[VC#]
public virtual string Result(
   string replacement
);

[VC++]
public: virtual String* Result(
   String* replacement
);

[JScript]
public function Result(
   replacement : String
) : String;

<end node> 5P9i0s8y19Z
dt=Text
<node>
Enumeration RegexOptions
1
Данное перечисление определяет значения, используемые для настройки параметров регулярного выражения.

Атрибут FlagsAttribute этого перечисления разрешает двоичные операции со значениями его членов.

Члены

Имя члена 
Описание 
Значение 
Compiled 
 Показывает, что регулярное выражение компилируется в сборку. Это обеспечивает более быстрое выполнение, но увеличивает время запуска.
8 
CultureInvariant 
Показывает, что культурные различия в языке игнорируются. Для получения дополнительных сведений см. Выполнение операций без учета региональных стандартов в пространстве имен RegularExpressions.
512 
ECMAScript 
Включает поведение для выражения, соответствующее ECMAScript. Данный флаг используется только в соединении с флагами IgnoreCase, Multiline и Compiled. Использование данного флага с любыми другими флагами приводит к возникновению исключения. 
256 
ExplicitCapture 
Указывает, что единственными допустимыми захватами являются явно именованные или пронумерованные группы формы (?<name>…). Это позволяет избежать излишней синтаксической сложности выражения при использовании безымянных круглых скобок для обозначения не захватывающей группы (?:…).
4 
IgnoreCase 
Указывает сопоставление, при котором регистр не учитывается. 1 
IgnorePatternWhitespace 
Устраняет из образца переключенный обратно пробел и включает комментарии, помеченные с помощью #. 
32 
Multiline 
Многострочный режим. Изменяет значение ^ и $ таким образом, что они стоят в начале и конце, соответственно, каждой строчки, а не только в начале и конце всей строки. 
2 
None 
Указывает отсутствие заданных параметров.
0 
RightToLeft 
Показывает, что поиск будет происходить справа налево, а не слева направо.
64 
Singleline 
Показывает однострочный режим. Изменяет значение точки (.) таким образом, что она означает каждый символ (вместо каждого символа за исключением\n). 
16 

<end node> 5P9i0s8y19Z
dt=Text
<node>
Class RegEx
1
RegEx -- Предоставляет постоянное регулярное выражение.

Список всех членов этого типа представлен в разделе Regex - члены.

Примечания
	Класс Regex содержит несколько статических методов, позволяющих использовать регулярное выражение без явного создания объекта Regex. Применение статического метода эквивалентно созданию объекта Regex, использованию его единожды и уничтожению.

	Класс Regex является постоянным (только для чтения) и по сути безопасным для потоков. Объекты Regex могут быть созданы в любом потоке и поделены между потоками.

Члены класса

Открытые конструкторы
Regex - конструктор 
Перегружен. Инициализирует новый экземпляр класса Regex. 

Открытые свойства
Options 
Возвращает параметры, переданные в конструктор Regex. 

RightToLeft 
Получает значение показывающее, выполняет ли регулярное выражение поиск справа налево. 

Открытые методы
static (Shared в Visual Basic)CompileToAssembly 
Перегружен. Компилирует регулярные выражения и сохраняет их на диск в отдельной сборке. 

Equals (унаследовано от Object) 
Перегружен. Определяет, равны ли два экземпляра Object. 

static (Shared в Visual Basic)Escape 
Переключает минимальный набор метасимволов (\, *, +, ?, |, {, [, (,), ^, $, ., # и пробел), замещая их кодами переключения режима. 

GetGroupNames 
Возвращает массив имен групп захвата для регулярного выражения. 

GetGroupNumbers 
Возвращает массив номеров групп захвата, соответствующих именам групп в массиве. 

GetHashCode (унаследовано от Object) 
Служит хеш-функцией для конкретного типа, пригоден для использования в алгоритмах хеширования и структурах данных, например в хеш-таблице. 

GetType (унаследовано от Object) 
Возвращает Type текущего экземпляра. 

GroupNameFromNumber 
Получает имя группы, соответствующее указанному номеру группы. 

GroupNumberFromName 
Возвращает номер группы, соответствующий указанному имени группы. 

IsMatch 
Перегружен. Показывает, обнаружен ли регулярным выражением подобный элемент в выходной строке. 

Match 
Перегружен. Просматривает входную строку в поисках вхождений регулярного выражения и возвращает точный результат в виде отдельного объекта Match. 

Matches 
Перегружен. Просматривает входную строку в поисках всех вхождений регулярного выражения и возвращает все успешные сопоставления, как если бы Match был вызван несколько раз. 

Replace 
Перегружен. Замещает все вхождения образца символов, определенного регулярным выражением с указанной строкой символов замещения. 

Split 
Перегружен. Разбивает входную строку на массив подстрок на позициях, определенных сопоставлением регулярного выражения. 

ToString 
Переопределен. Возвращает образец регулярного выражения, переданный в конструктор Regex. 

(Shared в Visual Basic)Unescape 
Переключает обратно символы переключения режима во входной строке. 

<end node> 5P9i0s8y19Z
dt=Text
<node>
Constructors
2
Перваый вариант -- Инициализирует и компилирует экземпляр класса Regex для указанного регулярного выражения.

Параметры
	pattern -- Образец регулярного выражения для сопоставления. 
Исключения
Тип исключения 
Условие 
ArgumentException 
Ошибка анализа регулярного выражения. 

Примечания
	Объект Regex является постоянным, это означает, что его можно использовать только для параметров сопоставления, определенных при его создании. Однако его допускается использовать неограниченное число раз без перекомпиляции.

Примеры описания:

[VB]
Public Sub New( _
   ByVal pattern As String _
)

[VC#]
public Regex(
   string pattern
);

[VC++]
public: Regex(
   String* pattern
);

[JScript]
public function Regex(
   pattern : String
);

Второй Вариант -- Инициализирует и компилирует экземпляр класса Regex для указанного регулярного выражения с параметрами, изменяющими образец.

Параметры
	pattern -- Образец регулярного выражения для сопоставления. 
	options -- Поразрядная комбинация OR значений перечисления RegexOption. 

Исключения:
Тип исключения 
Условие 
ArgumentException 
Ошибка анализа регулярного выражения. 

Примечания
	Объект Regex является постоянным, это означает, что его можно использовать только для параметров сопоставления, определенных при его создании. Однако его допускается использовать неограниченное число раз без перекомпиляции.

Примеры определения:

[VB]
Public Sub New( _
   ByVal pattern As String, _
   ByVal options As RegexOptions _
)

[VC#]
public Regex(
   string pattern,
   RegexOptions options
);

[VC++]
public: Regex(
   String* pattern,
   RegexOptions options
);

[JScript]
public function Regex(
   pattern : String,
   options : RegexOptions
);

<end node> 5P9i0s8y19Z
dt=Text
<node>
Options
2
Возвращает параметры, переданные в конструктор Regex.

Значение свойства
Параметр options, переданный в конструктор Regex.

Примеры определения:

[VB]
Public ReadOnly Property Options As RegexOptions

[VC#]
public RegexOptions Options {get;}

[VC++]
public: __property RegexOptions get_Options();

[JScript]
public function get Options() : RegexOptions;

<end node> 5P9i0s8y19Z
dt=Text
<node>
RightToLeft 
2
Получает значение показывающее, выполняет ли регулярное выражение поиск справа налево.

Значение свойства
true, если регулярное выражение выполняет поиск справа налево; в противном случае — false.

Примечания
RightToLeft является true, если экземпляр Regex был создан с параметром RightToLeft.

Примеры описания:

[VB]
Public ReadOnly Property RightToLeft As Boolean

[VC#]
public bool RightToLeft {get;}

[VC++]
public: __property bool get_RightToLeft();

[JScript]
public function get RightToLeft() : Boolean;

<end node> 5P9i0s8y19Z
dt=Text
<node>
Escape
2
Переключает минимальный набор метасимволов (\, *, +, ?, |, {, [, (,), ^, $, ., # и пробел), замещая их кодами переключения режима.

Параметры
	str -- Входная строка, содержащая текст для преобразования. 
Возвращаемое значение
	Строка символов с метасимволами, преобразованными с помощью режима переключения.

Примечания
	Escape преобразует строку таким образом, что ее можно безопасно использовать в качестве константы в регулярном выражении. (Символы знака (#) и пробела необходимо переключить так, чтобы строку можно было безопасно применять в выражении, анализируемом при включенном параметре IgnorePatternWhitespace. Если будущие функции регулярных выражений .NET добавят дополнительные метасимволы, Escape также преобразует эти символы с помощью переключения режима.)

Примеры описания:

[VB]
Public Shared Function Escape( _
   ByVal str As String _
) As String

[VC#]
public static string Escape(
   string str
);

[VC++]
public: static String* Escape(
   String* str
);

[JScript]
public static function Escape(
   str : String
) : String;

<end node> 5P9i0s8y19Z
dt=Text
<node>
GetGroupNames 
2
Возвращает массив имен групп захвата для регулярного выражения.

Возвращаемое значение
	Массив строк имен групп.

Примечания
	Коллекция имен групп содержит набор строк, применяемых для присвоения имен группам захвата в выражении. Даже если группы захвата не явно названы, им автоматически присваиваются числовые имена (1, 2, 3 и так далее). Поэтому данную коллекцию можно использовать для определения количества групп.

Требования

[VB]
Public Function GetGroupNames() As String()

[VC#]
public string[] GetGroupNames();

[VC++]
public: String* GetGroupNames()  __gc[];

[JScript]
public function GetGroupNames() : String[];

<end node> 5P9i0s8y19Z
dt=Text
<node>
GetGroupNumbers 
2
Возвращает массив номеров групп захвата, соответствующих именам групп в массиве.

Возвращаемое значение
	Целочисленный массив номеров групп.

Примечания
Имеется возможность получить более быстрый доступ, ссылаясь на группу по ее номеру, а не по имени строки.

Примеры описания:

[VB]
Public Function GetGroupNumbers() As Integer()

[VC#]
public int[] GetGroupNumbers();

[VC++]
public: int GetGroupNumbers()  __gc[];

[JScript]
public function GetGroupNumbers() : int[];

<end node> 5P9i0s8y19Z
dt=Text
<node>
GroupNameFromNumber 
2
Получает имя группы, соответствующее указанному номеру группы.

Параметры
	i  -- Номер группы для преобразования в соответствующее имя группы. 
Возвращаемое значение
	Строка, содержащая имя группы, связанное с указанным номером группы.

Примеры описания:

[VB]
Public Function GroupNameFromNumber( _
   ByVal i As Integer _
) As String

[VC#]
public string GroupNameFromNumber(
   int i
);

[VC++]
public: String* GroupNameFromNumber(
   int i
);

[JScript]
public function GroupNameFromNumber(
   i : int
) : String;

<end node> 5P9i0s8y19Z
dt=Text
<node>
GroupNumberFromName
2
Возвращает номер группы, соответствующий указанному имени группы.

Параметры
	name -- Имя группы для преобразования в соответствующий номер группы. 
Возвращаемое значение
	Номер группы, соответствующий указанному имени группы.

Примеры описания:

[VB]
Public Function GroupNumberFromName( _
   ByVal name As String _
) As Integer

[VC#]
public int GroupNumberFromName(
   string name
);

[VC++]
public: int GroupNumberFromName(
   String* name
);

[JScript]
public function GroupNumberFromName(
   name : String
) : int;

<end node> 5P9i0s8y19Z
dt=Text
<node>
IsMatch 
2
Данный метод имеет несколько форм вызова:

Первый вариант: 
Показывает, обнаружен ли регулярным выражением, указанным в конструкторе Regex, подобный элемент в выходной строке.

[VB]
Overloads Public Function IsMatch( _
   ByVal input As String _
) As Boolean

[VC#]
public bool IsMatch(
   string input
);

[VC++]
public: bool IsMatch(
   String* input
);

[JScript]
public function IsMatch(
   input : String
) : Boolean;

Второй вариант:
Показывает, обнаружен ли регулярным выражением, указанным в конструкторе Regex, подобный элемент в выходной строке, начиная от указанной начальной позиции в строке.

[VB]
Overloads Public Function IsMatch( _
   ByVal input As String, _
   ByVal startat As Integer _
) As Boolean

[VC#]
public bool IsMatch(
   string input,
   int startat
);

[VC++]
public: bool IsMatch(
   String* input,
   int startat
);

[JScript]
public function IsMatch(
   input : String,
   startat : int
) : Boolean;

Третий вариант:
Показывает, находит ли регулярное выражение подобный элемент в выходной строке, используя регулярное выражение, указанное в параметре pattern.

[VB]
Overloads Public Shared Function IsMatch( _
   ByVal input As String, _
   ByVal pattern As String _
) As Boolean

[VC#]
public static bool IsMatch(
   string input,
   string pattern
);

[VC++]
public: static bool IsMatch(
   String* input,
   String* pattern
);

[JScript]
public static function IsMatch(
   input : String,
   pattern : String
) : Boolean;

Четвёртый вариант:
Показывает, находит ли регулярное выражение подобный элемент в выходной строке, используя регулярное выражение, заданное параметром pattern, и параметры сопоставления, заданные параметром options.

[VB]
Overloads Public Shared Function IsMatch( _
   ByVal input As String, _
   ByVal pattern As String, _
   ByVal options As RegexOptions _
) As Boolean

[VC#]
public static bool IsMatch(
   string input,
   string pattern,
   RegexOptions options
);

[VC++]
public: static bool IsMatch(
   String* input,
   String* pattern,
   RegexOptions options
);

[JScript]
public static function IsMatch(
   input : String,
   pattern : String,
   options : RegexOptions
) : Boolean;

Параметры
	input -- Строка, вхождение которой требуется найти. 
	startat -- Позиция символа, откуда следует начать поиск. 
	pattern -- Образец регулярного выражения для сопоставления. 
	options -- Поразрядная комбинация OR значений перечисления RegexOption. 

Возвращаемое значение для всех вариантов синтаксиса:
	true, если регулярное выражение обнаруживает подобный элемент; в противном случае — false.

<end node> 5P9i0s8y19Z
dt=Text
<node>
Match
2
Просматривает входную строку в поисках вхождений регулярного выражения и возвращает точный результат в виде отдельного объекта Match.

Список перегрузки
Данная функция поддерживает пять вариантов синтаксиса:

Первый вариант.
Просматривает указанную входную строку в поиске вхождений регулярного выражения, указанного в конструкторе Regex.

[VB]
Overloads Public Function Match( _
   ByVal input As String _
) As Match

[VC#]
public Match Match(
   string input
);

[VC++]
public: Match* Match(
   String* input
);

[JScript]
public function Match(
   input : String
) : Match;

Второй вариант:
Просматривает входную строку в поисках вхождений регулярного выражения с указанной начальной позицией входной строки.

[VB]
Overloads Public Function Match( _
   ByVal input As String, _
   ByVal startat As Integer _
) As Match

[VC#]
public Match Match(
   string input,
   int startat
);

[VC++]
public: Match* Match(
   String* input,
   int startat
);

[JScript]
public function Match(
   input : String,
   startat : int
) : Match;

Третий вариант:
Просматривает указанную входную строку в поиске вхождений регулярного выражения, поставляемого в параметре pattern.

[VB]
Overloads Public Shared Function Match( _
   ByVal input As String, _
   ByVal pattern As String _
) As Match

[VC#]
public static Match Match(
   string input,
   string pattern
);

[VC++]
public: static Match* Match(
   String* input,
   String* pattern
);

[JScript]
public static function Match(
   input : String,
   pattern : String
) : Match;

Четвёртый вариант:
Просматривает входную строку в поисках вхождений регулярного выражения с указанной начальной позицией входной строки и длиной входной строки.

[VB]
Overloads Public Function Match( _
   ByVal input As String, _
   ByVal beginning As Integer, _
   ByVal length As Integer _
) As Match

[VC#]
public Match Match(
   string input,
   int beginning,
   int length
);

[VC++]
public: Match* Match(
   String* input,
   int beginning,
   int length
);

[JScript]
public function Match(
   input : String,
   beginning : int,
   length : int
) : Match;

Пятый вариант:
Просматривает входную строку в поисках вхождений регулярного выражения, поставляемого в параметре pattern с опциями сопоставления, поставляемыми в параметре options.

[VB]
Overloads Public Shared Function Match( _
   ByVal input As String, _
   ByVal pattern As String, _
   ByVal options As RegexOptions _
) As Match

[VC#]
public static Match Match(
   string input,
   string pattern,
   RegexOptions options
);

[VC++]
public: static Match* Match(
   String* input,
   String* pattern,
   RegexOptions options
);

[JScript]
public static function Match(
   input : String,
   pattern : String,
   options : RegexOptions
) : Match;

Параметры
	input -- Строка, вхождение которой требуется найти. 
	startat -- Позиция символа, откуда следует начать поиск. 
	pattern -- Образец регулярного выражения для сопоставления. 
	beginning -- Позиция символа в входной строке, откуда следует начать поиск. 
	length -- Число символов в подстроке, включенных в поиск. 
	options -- Поразрядная комбинация OR значений перечисления RegexOption. 

Возвращаемое значение
	Объект Match регулярного выражения.

Примечания
	При желании можно ограничить сопоставление так, чтобы не было сканирования. Для этого прикрепите регулярное выражение к\G (слева для образца слева-направо или справа для образца справа-налево). Сопоставление будет ограничено и будет начинаться точно с startpos.

	Если Regex является слева-направо (по умолчанию), сопоставление и просмотр происходят в правом направлении, начиная с символа в startat. Если Regex является справа-налево (созданный с активным параметром RightToLeft), сопоставление и просмотр происходят в обратном направлении и начинаются с символа в startat-1.

	Статические методы Match эквивалентны созданию объекта Regex с указанным образцом и последующим вызовом метода экземпляра Match. Статические методы нужны для того, чтобы предоставить изолированное, отдельное использование регулярного выражения без явного создания объекта Regex.

<end node> 5P9i0s8y19Z
dt=Text
<node>
Matches
2
Просматривает входную строку в поисках всех вхождений регулярного выражения и возвращает все успешные сопоставления, как если бы Match был вызван несколько раз.

Список перегрузки:
	Данная функция доступна в четырёх вариантах синтаксиса, совпадающих с вариантами синтаксиса для метода isMatch

Первый вариант:
Просматривает указанную входную строку в поисках всех вхождений регулярного выражения.

[VB]
Overloads Public Function Matches( _
   ByVal input As String _
) As MatchCollection

[VC#]
public MatchCollection Matches(
   string input
);

[VC++]
public: MatchCollection* Matches(
   String* input
);

[JScript]
public function Matches(
   input : String
) : MatchCollection;

Второй вариант:
Просматривает указанную входную строку в поисках всех вхождений регулярного выражения, начиная с указанной начальной позиции в строке.

[VB]
Overloads Public Function Matches( _
   ByVal input As String, _
   ByVal startat As Integer _
) As MatchCollection

[VC#]
public MatchCollection Matches(
   string input,
   int startat
);

[VC++]
public: MatchCollection* Matches(
   String* input,
   int startat
);

[JScript]
public function Matches(
   input : String,
   startat : int
) : MatchCollection;

Третий вариант:
Просматривает указанную входную строку в поисках всех вхождений регулярного выражения, указанного в параметре pattern.

[VB]
Overloads Public Shared Function Matches( _
   ByVal input As String, _
   ByVal pattern As String _
) As MatchCollection

[VC#]
public static MatchCollection Matches(
   string input,
   string pattern
);

[VC++]
public: static MatchCollection* Matches(
   String* input,
   String* pattern
);

[JScript]
public static function Matches(
   input : String,
   pattern : String
) : MatchCollection;

Четвёртый вариант:
Просматривает входную строку в поисках всех вхождений регулярного выражения, поставляемого в параметре pattern с опциями сопоставления, поставляемыми в параметре options.

[VB]
Overloads Public Shared Function Matches( _
   ByVal input As String, _
   ByVal pattern As String, _
   ByVal options As RegexOptions _
) As MatchCollection

[VC#]
public static MatchCollection Matches(
   string input,
   string pattern,
   RegexOptions options
);

[VC++]
public: static MatchCollection* Matches(
   String* input,
   String* pattern,
   RegexOptions options
);

[JScript]
public static function Matches(
   input : String,
   pattern : String,
   options : RegexOptions
) : MatchCollection;

Параметры
	input -- Строка, вхождение которой требуется найти. 
	startat -- Позиция символа, откуда следует начать поиск. 
	pattern -- Образец регулярного выражения для сопоставления. 
	options -- Поразрядная комбинация OR значений перечисления RegexOption. 

Возвращаемое значение
	MatchCollection объектов Match, найденных при поиске.

Примечания
	Методы Matches подобны методам Match, за исключением того, что они возвращают список успешных сопоставлений, полученных при итеративном вызове= Match (...), затем Match.NextMatch () и так далее. Коллекция включает только успешные сопоставления и завершается при первом неудачном сопоставлении.

<end node> 5P9i0s8y19Z
dt=Text
<node>
Replace 
2
Замещает все вхождения образца символов, определенного регулярным выражением с указанной строкой символов замещения.

Список перегрузки
Функция поддерживает десять вариантов синтаксиса:

Первый вариант:
Замещает все вхождения образца символа, определенного регулярным выражением, указанным в конструкторе Regex. Вызов делегата MatchEvaluator происходит при каждом сопоставлении для оценки замещения.

[VB]
Overloads Public Function Replace( _
   ByVal input As String, _
   ByVal evaluator As MatchEvaluator _
) As String

[VC#]
public string Replace(
   string input,
   MatchEvaluator evaluator
);

[VC++]
public: String* Replace(
   String* input,
   MatchEvaluator* evaluator
);

[JScript]
public function Replace(
   input : String,
   evaluator : MatchEvaluator
) : String;

Второй вариант:
Замещает все вхождения указанного образца регулярного выражения со строкой замещения, начиная с первого символа во входной строке.

[VB]
Overloads Public Function Replace( _
   ByVal input As String, _
   ByVal replacement As String _
) As String

[VC#]
public string Replace(
   string input,
   string replacement
);

[VC++]
public: String* Replace(
   String* input,
   String* replacement
);

[JScript]
public function Replace(
   input : String,
   replacement : String
) : String;

Третий вариант:
Замещает указанное количество вхождений образца, определенного регулярным выражением, указанного в конструкторе Regex со строкой замещения, начиная с первого символа во входной строке. Вызов делегата MatchEvaluator происходит при каждом сопоставлении для оценки замещения.

[VB]
Overloads Public Function Replace( _
   ByVal input As String, _
   ByVal evaluator As MatchEvaluator, _
   ByVal count As Integer _
) As String

[VC#]
public string Replace(
   string input,
   MatchEvaluator evaluator,
   int count
);

[VC++]
public: String* Replace(
   String* input,
   MatchEvaluator* evaluator,
   int count
);

[JScript]
public function Replace(
   input : String,
   evaluator : MatchEvaluator,
   count : int
) : String;

Четвёртый вариант:
Замещает указанное количество вхождений образца, определенного регулярным выражением, указанного в конструкторе Regex с указанной строкой замещения, начиная с первого символа во входной строке.

[VB]
Overloads Public Function Replace( _
   ByVal input As String, _
   ByVal replacement As String, _
   ByVal count As Integer _
) As String

[VC#]
public string Replace(
   string input,
   string replacement,
   int count
);

[VC++]
public: String* Replace(
   String* input,
   String* replacement,
   int count
);

[JScript]
public function Replace(
   input : String,
   replacement : String,
   count : int
) : String;

Пятый вариант:
Замещает все вхождения образца символов, определенного регулярным выражением со строкой символов замещения, начиная с первого символа. Вызов делегата MatchEvaluator происходит при каждом сопоставлении для оценки замещения.

[VB]
Overloads Public Shared Function Replace( _
   ByVal input As String, _
   ByVal pattern As String, _
   ByVal evaluator As MatchEvaluator _
) As String

[VC#]
public static string Replace(
   string input,
   string pattern,
   MatchEvaluator evaluator
);

[VC++]
public: static String* Replace(
   String* input,
   String* pattern,
   MatchEvaluator* evaluator
);

[JScript]
public static function Replace(
   input : String,
   pattern : String,
   evaluator : MatchEvaluator
) : String;

Шестой вариант:
Замещает все вхождения сопоставлений, определенных регулярным выражением со строкой замещения, начиная с первого символа во входной строке.

[VB]
Overloads Public Shared Function Replace( _
   ByVal input As String, _
   ByVal pattern As String, _
   ByVal replacement As String _
) As String

[VC#]
public static string Replace(
   string input,
   string pattern,
   string replacement
);

[VC++]
public: static String* Replace(
   String* input,
   String* pattern,
   String* replacement
);

[JScript]
public static function Replace(
   input : String,
   pattern : String,
   replacement : String
) : String;

Седьмой вариант:
Замещает указанное количество вхождений образца, указанного в конструкторе Regex со строкой замещения, начиная с указанной позиции символа во входной строке. Вызов делегата MatchEvaluator происходит при каждом сопоставлении для оценки замещения.

[VB]
Overloads Public Function Replace( _
   ByVal input As String, _
   ByVal evaluator As MatchEvaluator, _
   ByVal count As Integer, _
   ByVal startat As Integer _
) As String

[VC#]
public string Replace(
   string input,
   MatchEvaluator evaluator,
   int count,
   int startat
);

[VC++]
public: String* Replace(
   String* input,
   MatchEvaluator* evaluator,
   int count,
   int startat
);

[JScript]
public function Replace(
   input : String,
   evaluator : MatchEvaluator,
   count : int,
   startat : int
) : String;

Восьмой вариант:
Замещает указанное количество вхождений образца во входной строке, определенной регулярным выражением, указанным в конструкторе Regex с указанной строкой замещения, начиная с указанной позиции символа во входной строке.

[VB]
Overloads Public Function Replace( _
   ByVal input As String, _
   ByVal replacement As String, _
   ByVal count As Integer, _
   ByVal startat As Integer _
) As String

[VC#]
public string Replace(
   string input,
   string replacement,
   int count,
   int startat
);

[VC++]
public: String* Replace(
   String* input,
   String* replacement,
   int count,
   int startat
);

[JScript]
public function Replace(
   input : String,
   replacement : String,
   count : int,
   startat : int
) : String;

Девятый вариант:
Замещает все вхождения образца символов, определенного указанным регулярным выражением со строкой символов замещения, начиная с первого символа. Имеется возможность указать параметры для изменения поведения сопоставления и вызова делегата MatchEvaluator при каждом сопоставлении, чтобы оценивать замещение.

[VB]
Overloads Public Shared Function Replace( _
   ByVal input As String, _
   ByVal pattern As String, _
   ByVal evaluator As MatchEvaluator, _
   ByVal options As RegexOptions _
) As String

[VC#]
public static string Replace(
   string input,
   string pattern,
   MatchEvaluator evaluator,
   RegexOptions options
);

[VC++]
public: static String* Replace(
   String* input,
   String* pattern,
   MatchEvaluator* evaluator,
   RegexOptions options
);

[JScript]
public static function Replace(
   input : String,
   pattern : String,
   evaluator : MatchEvaluator,
   options : RegexOptions
) : String;

Десятый вариант:
Замещает все вхождения образца, определенного указанным регулярным выражением с указанной строкой символов замещения, начиная с первого символа во входной строке. Допускается указать параметры для изменения поведения сопоставления.

[VB]
Overloads Public Shared Function Replace( _
   ByVal input As String, _
   ByVal pattern As String, _
   ByVal replacement As String, _
   ByVal options As RegexOptions _
) As String

[VC#]
public static string Replace(
   string input,
   string pattern,
   string replacement,
   RegexOptions options
);

[VC++]
public: static String* Replace(
   String* input,
   String* pattern,
   String* replacement,
   RegexOptions options
);

[JScript]
public static function Replace(
   input : String,
   pattern : String,
   replacement : String,
   options : RegexOptions
) : String;

Параметры
	input -- Строка для изменения. 
	replacement -- Замещаемая строка. 
	evaluator -- MatchEvaluator оценивает каждый этап замещения. 
	count -- Максимальное количество случаев замещения. 
	pattern -- Образец регулярного выражения для сопоставления. 
	startat -- Позиция символа во входной строке, откуда начнется поиск. 
	options -- Поразрядная комбинация OR значений перечисления RegexOption. 

Возвращаемое значение
	Измененная строка символов.

Примечания
	Тип MatchEvaluator является делегатом, который берет отдельное Match в качестве входных данных и возвращает строку. Это объявляется следующим образом:

	public delegate String RegexMatchEvaluator(Match match);
	Во время замещения делегат вызывается единожды для каждого сопоставления.

<end node> 5P9i0s8y19Z
dt=Text
<node>
Split 
2
Разбивает входную строку на массив подстрок на позициях, определенных сопоставлением регулярного выражения.

Список перегрузки
	Функция имеет пять вариантов синтаксиса.

Первый вариант:
Разбивает указанную входную строку в местах, определенных регулярным выражением, указанным в конструкторе Regex.

[VB]
Overloads Public Function Split( _
   ByVal input As String _
) As String()

[VC#]
public string[] Split(
   string input
);

[VC++]
public: String* Split(
   String* input
)  __gc[];

[JScript]
public function Split(
   input : String
) : String[];

Второй вариант:
Разбивает указанную входную строку указанное максимальное количество раз в местах, определенных регулярным выражением, указанным в конструкторе Regex.

[VB]
Overloads Public Function Split( _
   ByVal input As String, _
   ByVal count As Integer _
) As String()

[VC#]
public string[] Split(
   string input,
   int count
);

[VC++]
public: String* Split(
   String* input,
   int count
)  __gc[];

[JScript]
public function Split(
   input : String,
   count : int
) : String[];

Третий вариант:
Разбивает входную строку в местах, определенных образцом регулярного выражения.

[VB]
Overloads Public Shared Function Split( _
   ByVal input As String, _
   ByVal pattern As String _
) As String()

[VC#]
public static string[] Split(
   string input,
   string pattern
);

[VC++]
public: static String* Split(
   String* input,
   String* pattern
)  __gc[];

[JScript]
public static function Split(
   input : String,
   pattern : String
) : String[];

Четвёртый вариант:
Разбивает указанную входную строку указанное максимальное количество раз в местах, определенных регулярным выражением, указанным в конструкторе Regex, начиная с указанной позиции символа во входной строке.

[VB]
Overloads Public Function Split( _
   ByVal input As String, _
   ByVal count As Integer, _
   ByVal startat As Integer _
) As String()

[VC#]
public string[] Split(
   string input,
   int count,
   int startat
);

[VC++]
public: String* Split(
   String* input,
   int count,
   int startat
)  __gc[];

[JScript]
public function Split(
   input : String,
   count : int,
   startat : int
) : String[];

Пятый вариант:
Разбивает входную строку в местах, определенных указанным образцом регулярного выражения. Допускается указать параметры для изменения поведения сопоставления.

[VB]
Overloads Public Shared Function Split( _
   ByVal input As String, _
   ByVal pattern As String, _
   ByVal options As RegexOptions _
) As String()

[VC#]
public static string[] Split(
   string input,
   string pattern,
   RegexOptions options
);

[VC++]
public: static String* Split(
   String* input,
   String* pattern,
   RegexOptions options
)  __gc[];

[JScript]
public static function Split(
   input : String,
   pattern : String,
   options : RegexOptions
) : String[];

Параметры
	input -- Разбиваемая строка. 
	count -- Максимальное число возвращаемых элементов массива. 
	pattern -- Регулярное выражение для сопоставления. 
	startat -- Позиция символа во входной строке, откуда начнется поиск. 
	options -- Поразрядная комбинация OR значений перечисления RegexOption. 

Возвращаемое значение
	Массив строк.

Примечания
	Методы Regex.Split схожи с методом Split за исключением того, что данный метод разбивает строку, используя разделитель, определяемый регулярным выражением, а не набор знаков. Если указан count, строка разбивается максимум на count строк (последняя строка содержит неразбитый остаток строки); нулевое значение count обеспечивает стандартное поведение разбивки столько раз, сколько это возможно. Если указан startat, поиск первого разделителя происходит, начиная с указанной точки (этим можно воспользоваться, например, для пропуска предшествующих пробелов).

	Если группы захвата применяются в выражении Regex.Split, они включаются в результирующий массив строк. Следующий пример выдает элементы массива «one», «-», «two», «-», «banana».

Regex r = new Regex("(-)"); // Split on hyphens.
string[] s = r.Split("one-two-banana");

	Если регулярное выражение сопоставимо с пустой строкой (например, x*), Split разобьет строку на массив строк, состоящих из одного символа, потому что разделитель пустой строки можно найти в любом месте.Статические методы Split эквивалентны созданию объекта Regex с указанным образцом регулярного выражения с последующим вызовом метода экземпляра Split. Статические методы нужны для того, чтобы предоставить изолированное, отдельное использование регулярного выражения без явного создания объекта Regex.

<end node> 5P9i0s8y19Z
dt=Text
<node>
Unescape
2
Переключает обратно символы переключения режима во входной строке.

Параметры
	str -- Входная строка, содержащая текст для преобразования. 
Возвращаемое значение
	Строка символов с символами переключения режима, преобразованными обратно в состояние до переключения.

Примечания
	Например, Unescape замещает\x61 на a, а \n на символ новой строки (ASCII 10). Обратное переключение изменяет преобразования, сделанные Escape, на противоположные. (Конечно, Escape не в состоянии совершенно изменить Unescape на противоположное, потому что не может проследить в измененной обратно строке, какие символы до этого были переключены.)

Примеры описания:

[VB]
Public Shared Function Unescape( _
   ByVal str As String _
) As String

[VC#]
public static string Unescape(
   string str
);

[VC++]
public: static String* Unescape(
   String* str
);

[JScript]
public static function Unescape(
   str : String
) : String;

<end node> 5P9i0s8y19Z
